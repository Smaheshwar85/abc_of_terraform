hcl
Copy code
resource "google_service_account" "metric_reader" {
  account_id   = var.account_id
  project_id   = var.project_id
  display_name = var.display_name
}

resource "google_project_iam_member" "metric_reader_viewer" {
  project_id = var.project_id
  role       = "roles/monitoring.viewer"
  member     = "serviceAccount:${google_service_account.metric_reader.email}"
}

resource "google_project_iam_member" "workload_identity_user" {
  project_id      = var.project_id
  role            = "roles/iam.workloadIdentityUser"
  member          = "serviceAccount:${var.cluster_project_id}.svc.id.goog[${var.k8s_namespace}/${var.metric_reader_k8s_account}]"
}

# Output service account email
output "service_account_email" {
  value = google_service_account.metric_reader.email
}

output "service_account_name" {
  value = google_service_account.metric_reader.name
}
Variables: service_account_module/variables.tf
hcl
Copy code
variable "account_id" {
  description = "The account id for the service account"
  type        = string
}

variable "project_id" {
  description = "The GCP project id"
  type        = string
}

variable "display_name" {
  description = "The display name for the service account"
  type        = string
  default     = "Grafana Service Account"
}

variable "cluster_project_id" {
  description = "The cluster project id where the workload identity will be used"
  type        = string
}

variable "k8s_namespace" {
  description = "The Kubernetes namespace where the service account resides"
  type        = string
}

variable "metric_reader_k8s_account" {
  description = "The name of the Kubernetes service account"
  type        = string
}
Example Usage for an Application: application/main.tf
hcl
Copy code
module "grafana_service_account" {
  source = "../service_account_module"

  account_id                = "grafana-metric-reader"
  project_id                = "abc123"
  display_name              = "Grafana Metric Reader Service Account"
  cluster_project_id        = "jproject234"
  k8s_namespace             = "grafana-monitoring"
  metric_reader_k8s_account = "metric_reader"
}
Test Configuration: basic.tftest.hcl
hcl
Copy code
module "test_grafana_service_account" {
  source = "./service_account_module"

  account_id                = "test-metric-reader"
  project_id                = "test-project-id"
  display_name              = "Test Metric Reader"
  cluster_project_id        = "test-cluster-project-id"
  k8s_namespace             = "test-namespace"
  metric_reader_k8s_account = "test-metric-reader"
}

output "service_account_email" {
  value = module.test_grafana_service_account.service_account_email
}

output "service_account_name" {
  value = module.test_grafana_service_account.service_account_name
}
How to Test
To run the test, execute the following command in the folder where basic.tftest.hcl resides:

bash
Copy code
terraform init
terraform apply
This setup ensures that the module is reusable and flexible for different applications, and the tftest.hcl allows for basic testing to validate that the service account and IAM bindings are created correctly.






You said:
create a test file using run "basic_apply_valid_variables"
ChatGPT said:
ChatGPT
To create a test file using terraform's tftest framework and running basic_apply_valid_variables, here’s how you can structure the test file to verify that the module is working correctly. The test will ensure that valid inputs lead to a successful creation of the resources.

Test File: test_service_account.tf
hcl
Copy code
terraform {
  required_providers {
    google = {
      source  = "hashicorp/google"
      version = "~> 4.0"
    }
  }
}

# Define the test function for applying the valid variables
tftest "basic_apply_valid_variables" {
  test_name = "Basic apply with valid variables"
  
  # Load variables from a valid configuration
  variables = {
    account_id                = "test-metric-reader"
    project_id                = "test-project-id"
    display_name              = "Test Metric Reader"
    cluster_project_id        = "test-cluster-project-id"
    k8s_namespace             = "test-namespace"
    metric_reader_k8s_account = "test-metric-reader"
  }

  # Expected outputs
  expected_outputs = {
    service_account_email = "test-metric-reader@test-project-id.iam.gserviceaccount.com"
    service_account_name  = "projects/test-project-id/serviceAccounts/test-metric-reader@test-project-id.iam.gserviceaccount.com"
  }

  # Execute basic apply
  apply = true
}
Explanation:
Variables: The variables block in the tftest uses the expected values as input for your module. You can replace these with other valid data if needed for further testing.
Expected Outputs: These values are what you expect the module to output after applying the basic_apply_valid_variables test. Make sure they are accurate to your setup (e.g., the project ID and account ID).
Apply: The test will apply the configuration using the provided variables.
Running the Test
You can run this test by executing the following commands:

Initialize Terraform:

bash
Copy code
terraform init
Run the Test:

bash
Copy code
terraform apply -var-file=test_service_account.tf
This test will verify that when valid variables are supplied, the module creates the service account and applies the required IAM roles successfully.






You said:
add the different assert condition with the above test code
ChatGPT said:
ChatGPT
To enhance the test with different assert conditions, you can add checks for specific outputs, resource existence, and state validation using tftest. Here’s how you can expand the test by asserting the expected behavior of the Terraform module.

Test File with Asserts: test_service_account.tf
hcl
Copy code
terraform {
  required_providers {
    google = {
      source  = "hashicorp/google"
      version = "~> 4.0"
    }
  }
}

# Define the test function for applying the valid variables
tftest "basic_apply_valid_variables" {
  test_name = "Basic apply with valid variables"
  
  # Load variables from a valid configuration
  variables = {
    account_id                = "test-metric-reader"
    project_id                = "test-project-id"
    display_name              = "Test Metric Reader"
    cluster_project_id        = "test-cluster-project-id"
    k8s_namespace             = "test-namespace"
    metric_reader_k8s_account = "test-metric-reader"
  }

  # Execute basic apply
  apply = true

  # Expected outputs
  expected_outputs = {
    service_account_email = "test-metric-reader@test-project-id.iam.gserviceaccount.com"
    service_account_name  = "projects/test-project-id/serviceAccounts/test-metric-reader@test-project-id.iam.gserviceaccount.com"
  }

  # Assert conditions

  # Assert that the service account email matches the expected format
  assert {
    condition     = module.test_grafana_service_account.service_account_email == "test-metric-reader@test-project-id.iam.gserviceaccount.com"
    error_message = "Service account email does not match the expected format."
  }

  # Assert that the service account name is in the correct project
  assert {
    condition     = module.test_grafana_service_account.service_account_name == "projects/test-project-id/serviceAccounts/test-metric-reader@test-project-id.iam.gserviceaccount.com"
    error_message = "Service account name is incorrect or in the wrong project."
  }

  # Assert that the Google IAM role "monitoring.viewer" is applied to the service account
  assert {
    condition     = google_project_iam_member.metric_reader_viewer.role == "roles/monitoring.viewer"
    error_message = "Monitoring viewer role not assigned to the service account."
  }

  # Assert that Workload Identity User IAM role is correctly assigned to the Kubernetes service account
  assert {
    condition     = google_project_iam_member.workload_identity_user.role == "roles/iam.workloadIdentityUser"
    error_message = "Workload Identity User role not correctly assigned."
  }

  # Assert the service account resource exists in the state
  assert {
    condition     = google_service_account.metric_reader != null
    error_message = "Service account resource not created."
  }

  # Assert that the service account display name matches the expected value
  assert {
    condition     = google_service_account.metric_reader.display_name == "Test Metric Reader"
    error_message = "Service account display name does not match."
  }

}
Explanation of Assertions:
Service Account Email Assertion: This checks if the service_account_email output matches the expected format.

Service Account Name Assertion: Ensures that the service account is created in the correct project and has the right naming convention.

IAM Role "monitoring.viewer" Assertion: Verifies that the roles/monitoring.viewer IAM role has been assigned to the service account.

Workload Identity User IAM Role Assertion: Checks whether the Kubernetes service account is correctly bound to the roles/iam.workloadIdentityUser role.

Resource Existence Assertion: Confirms that the service account resource was created and exists in the Terraform state.

Service Account Display Name Assertion: Ensures that the display name of the created service account matches the provided value.

Running the Test with Asserts
Initialize Terraform:

bash
Copy code
terraform init
Run the Test:

bash
Copy code
terraform apply -var-file=test_service_account.tf
The test will now check these conditions, ensuring the service account, IAM roles, and related resources behave as expected. If any assertion fails, an error message will indicate the cause.






===================================================================================================================================================================




import os
import sys
import time
import logging
from google.api_core.client_options import ClientOptions
from google.cloud.monitoring import MetricServiceClient
from google.cloud import logging as gcp_logging  # Import Google Cloud Logging
from opentelemetry import metrics
from opentelemetry.exporter.cloud_monitoring import CloudMonitoringMetricsExporter
from opentelemetry.sdk.metrics import MeterProvider
from opentelemetry.sdk.metrics.export import PeriodicExportingMetricReader
from opentelemetry.sdk.resources import (
    get_aggregated_resources,
    ProcessResourceDetector
)
from google.oauth2 import service_account  # Import service account for authentication

# Fetch project ID and service account file for Monitoring API
GOOGLE_CLOUD_PROJECT = os.getenv("GOOGLE_CLOUD_PROJECT", "your-project-id")
SA_FILENAME = os.getenv("SA_FILENAME", "path/to/service-account-file.json")

# Define Monitoring API endpoint
MONITORING_API_ENDPOINT = os.getenv("MONITORING_API_ENDPOINT", "https://monitoring.googleapis.com")
LOGGING_API_ENDPOINT = os.getenv("LOGGING_API_ENDPOINT", "https://logging.googleapis.com")

# Function to create and return Metrics and Logging clients using client options
def create_clients(api_endpoint, logging_endpoint, sa_filename):
    print("Creating clients with API endpoint: {} and Logging endpoint: {}".format(api_endpoint, logging_endpoint))
    
    # Use service account credentials
    credentials = service_account.Credentials.from_service_account_file(sa_filename)

    # Set client options with custom API endpoints
    metrics_options = ClientOptions(credentials=credentials, api_endpoint=api_endpoint)
    logging_options = ClientOptions(credentials=credentials, api_endpoint=logging_endpoint)
    
    # Create MetricServiceClient
    print("Initializing MetricServiceClient...")
    metrics_client = MetricServiceClient(client_options=metrics_options)
    print("MetricServiceClient created successfully.")

    # Create Google Cloud Logging client with custom options
    print("Initializing Google Cloud Logging client...")
    logging_client = gcp_logging.Client(credentials=credentials)
    print("Google Cloud Logging client created successfully.")

    return metrics_client, logging_client

# Function to create and configure OpenTelemetry's Meter with Cloud Monitoring Metrics Exporter
def get_meter(api_endpoint=MONITORING_API_ENDPOINT, logging_endpoint=LOGGING_API_ENDPOINT, project_id=GOOGLE_CLOUD_PROJECT, sa_filename=SA_FILENAME):
    print("Getting meter and logging client...")
    
    # Initialize MetricServiceClient and Logging client
    metrics_client, logging_client = create_clients(api_endpoint, logging_endpoint, sa_filename)
    
    print("Setting up MeterProvider with Cloud Monitoring exporter...")
    
    # Set up the meter provider with Cloud Monitoring exporter and resource detectors
    metrics.set_meter_provider(
        MeterProvider(
            metric_readers=[
                PeriodicExportingMetricReader(
                    CloudMonitoringMetricsExporter(
                        project_id=project_id,
                        client=metrics_client  # Pass the monitoring client to the exporter
                    ),
                    export_interval_millis=5000,  # Export interval set to 5 seconds
                )
            ],
            resource=get_aggregated_resources(
                [ProcessResourceDetector(raise_on_error=True)]  # Add process resources
            ),
        )
    )
    print("MeterProvider setup completed.")
    
    meter = metrics.get_meter(__name__)  # Return the configured meter
    print("Meter created successfully.")
    
    return meter, logging_client

# Function to get additional metrics properties (can be extended as needed)
def get_metrics_properties():
    environment = os.getenv("MONITORING_ENV", "staging")
    print("Metrics properties - environment: {}".format(environment))
    
    return {
        "environment": environment,
    }

# Function to create OpenTelemetry instruments (counter for IAM errors)
def get_instruments():
    print("Getting instruments (IAM error counter)...")
    
    meter, logging_client = get_meter()
    
    # Create IAM error counter with dynamic name and description
    counter_name = os.getenv("MONITORING_METRICS_IAM_ERROR_COUNTER_NAME", "iam_error_counter")
    counter_description = os.getenv("MONITORING_METRICS_IAM_ERROR_COUNTER_DESCRIPTION", "Tracks IAM errors")
    print("Creating IAM error counter: {}, description: {}".format(counter_name, counter_description))
    
    iam_error_counter = meter.create_counter(
        name=counter_name,
        description=counter_description,
    )
    
    print("IAM error counter created successfully.")
    
    return iam_error_counter, logging_client

# Function to check for IAM errors in logs and increment the counter
def check_for_iam_errors(iam_error_counter, logging_client):
    logger = logging.getLogger(__name__)
    logger.addHandler(gcp_logging.handlers.CloudLoggingHandler(logging_client))
    logger.info("Checking for IAM errors...")
    print("Checking for IAM errors in logs...")
    
    # Create a filter to fetch logs related to IAM errors for any resource
    filter_str = 'severity="ERROR" AND textPayload:"IAM"'
    print("Log filter used: {}".format(filter_str))
    
    # Fetch logs with the filter for IAM errors
    for entry in logging_client.logger("IAM_Error_Logger").list_entries(filter_=filter_str):
        print("IAM error detected in log: {}".format(entry.payload))
        
        # Increment the IAM error counter if an error entry is found
        labels = get_metrics_properties()  # Add custom labels
        iam_error_counter.add(1, labels)
        logger.info("IAM error detected: {}".format(entry.payload))

# Main loop to check for IAM errors and update metrics periodically
def main():
    print("Starting the main loop...")
    
    # Get the IAM error counter instrument and logging client
    iam_error_counter, logging_client = get_instruments()
    
    # Loop to check for IAM errors every 5 seconds
    while True:
        print("Running IAM error check cycle...")
        check_for_iam_errors(iam_error_counter, logging_client)
        time.sleep(5)
        print("Sleeping for 5 seconds before the next check...")

if __name__ == "__main__":
    main()
kkkkkkkkkk

import os
import time
import logging
from google.api_core.client_options import ClientOptions
from google.cloud.monitoring_v3 import MetricServiceClient
from google.cloud import logging as gcp_logging  # Import Google Cloud Logging
from google.oauth2 import service_account
from opentelemetry import metrics
from opentelemetry.exporter.cloud_monitoring import CloudMonitoringMetricsExporter
from opentelemetry.sdk.metrics import MeterProvider
from opentelemetry.sdk.metrics.export import PeriodicExportingMetricReader
from opentelemetry.sdk.resources import (
    get_aggregated_resources,
    ProcessResourceDetector
)

# Fetch project ID and service account file for Monitoring API
GOOGLE_CLOUD_PROJECT = os.getenv("GOOGLE_CLOUD_PROJECT", "your-project-id")
SA_FILENAME = os.getenv("SA_FILENAME", "path/to/service-account-file.json")

# Define Monitoring API endpoint
MONITORING_API_ENDPOINT = os.getenv("MONITORING_API_ENDPOINT", "https://monitoring.googleapis.com")
LOGGING_API_ENDPOINT = os.getenv("LOGGING_API_ENDPOINT", "https://logging.googleapis.com")

# Scopes for Google Cloud Logging and Monitoring
SCOPES = [
    'https://www.googleapis.com/auth/logging.read',
    'https://www.googleapis.com/auth/monitoring'
]

# Function to create and return Metrics and Logging clients using service account credentials
def create_clients(api_endpoint: str, logging_endpoint: str, sa_filename: str) -> (MetricServiceClient, gcp_logging.Client):
    print(f"Creating clients with API endpoint: {api_endpoint} and Logging endpoint: {logging_endpoint}")
    
    # Load credentials from service account file
    credentials = service_account.Credentials.from_service_account_file(sa_filename, scopes=SCOPES)
    
    # Set client options with the API endpoint
    metrics_options = ClientOptions(api_endpoint=api_endpoint)
    logging_options = ClientOptions(api_endpoint=logging_endpoint)
    
    # Create MetricServiceClient
    print("Initializing MetricServiceClient...")
    metrics_client = MetricServiceClient(credentials=credentials, client_options=metrics_options)
    print("MetricServiceClient created successfully.")

    # Create Google Cloud Logging client
    print("Initializing Google Cloud Logging client...")
    logging_client = gcp_logging.Client(credentials=credentials, client_options=logging_options, project=GOOGLE_CLOUD_PROJECT)
    print("Google Cloud Logging client created successfully.")

    return metrics_client, logging_client

# Function to create and configure OpenTelemetry's Meter with Cloud Monitoring Metrics Exporter
def get_meter(
    api_endpoint: str = MONITORING_API_ENDPOINT,
    logging_endpoint: str = LOGGING_API_ENDPOINT,
    project_id: str = GOOGLE_CLOUD_PROJECT,
    sa_filename: str = SA_FILENAME,
) -> (metrics.Meter, gcp_logging.Client):
    print("Getting meter and logging client...")
    
    # Initialize MetricServiceClient and Logging client
    metrics_client, logging_client = create_clients(api_endpoint, logging_endpoint, sa_filename)
    
    print("Setting up MeterProvider with Cloud Monitoring exporter...")
    
    # Set up the meter provider with Cloud Monitoring exporter and resource detectors
    metrics.set_meter_provider(
        MeterProvider(
            metric_readers=[
                PeriodicExportingMetricReader(
                    CloudMonitoringMetricsExporter(
                        project_id=project_id,
                        client=metrics_client  # Pass the monitoring client to the exporter
                    ),
                    export_interval_millis=5000,  # Export interval set to 5 seconds
                )
            ],
            resource=get_aggregated_resources(
                [ProcessResourceDetector(raise_on_error=True)]  # Add process resources
            ),
        )
    )
    print("MeterProvider setup completed.")
    
    meter = metrics.get_meter(__name__)  # Return the configured meter
    print("Meter created successfully.")
    
    return meter, logging_client

# Function to get additional metrics properties (can be extended as needed)
def get_metrics_properties():
    environment = os.getenv("MONITORING_ENV", "staging")
    print(f"Metrics properties - environment: {environment}")
    
    return {
        "environment": environment,
    }

# Function to create OpenTelemetry instruments (counter for IAM errors)
def get_instruments():
    print("Getting instruments (IAM error counter)...")
    
    meter, logging_client = get_meter()
    
    # Create IAM error counter with dynamic name and description
    counter_name = os.getenv("MONITORING_METRICS_IAM_ERROR_COUNTER_NAME", "iam_error_counter")
    counter_description = os.getenv("MONITORING_METRICS_IAM_ERROR_COUNTER_DESCRIPTION", "Tracks IAM errors")
    print(f"Creating IAM error counter: {counter_name}, description: {counter_description}")
    
    iam_error_counter = meter.create_counter(
        name=counter_name,
        description=counter_description,
    )
    
    print("IAM error counter created successfully.")
    
    return iam_error_counter, logging_client

# Function to check for IAM errors in logs and increment the counter
def check_for_iam_errors(iam_error_counter, logging_client):
    logger = logging.getLogger(__name__)
    logger.addHandler(gcp_logging.handlers.CloudLoggingHandler(logging_client))
    logger.info("Checking for IAM errors...")
    print("Checking for IAM errors in logs...")
    
    # Create a filter to fetch logs related to IAM errors for any resource
    filter_str = 'severity="ERROR" AND textPayload:"IAM"'
    print(f"Log filter used: {filter_str}")
    
    # Fetch logs with the filter for IAM errors
    for entry in logging_client.logger("IAM_Error_Logger").list_entries(filter_=filter_str):
        print(f"IAM error detected in log: {entry.payload}")
        
        # Increment the IAM error counter if an error entry is found
        labels = get_metrics_properties()  # Add custom labels
        iam_error_counter.add(1, labels)
        logger.info(f"IAM error detected: {entry.payload}")

# Main loop to check for IAM errors and update metrics periodically
def main():
    print("Starting the main loop...")
    
    # Get the IAM error counter instrument and logging client
    iam_error_counter, logging_client = get_instruments()
    
    # Loop to check for IAM errors every 5 seconds
    while True:
        print("Running IAM error check cycle...")
        check_for_iam_errors(iam_error_counter, logging_client)
        time.sleep(5)
        print("Sleeping for 5 seconds before the next check...")

if __name__ == "__main__":
    main()
